
  🏗️ JavaScript 클래스 기초

  클래스가 뭔가요?

  클래스는 **"객체를 만드는 설계도"** 라고 생각하면 돼요!

  비유:
  - 클래스 = 붕어빵 틀 🧁
  - 객체(인스턴스) = 실제 붕어빵들

  ---
  1. 클래스 없이 객체 만들기 (옛날 방식)

  ```js
  // 사용자 객체 여러 개 만들기
  const user1 = {
    name: '홍길동',
    age: 25,
    greet: function() {
      console.log(`안녕하세요, ${this.name}입니다!`);
    }
  };

  const user2 = {
    name: '김철수',
    age: 30,
    greet: function() {
      console.log(`안녕하세요, ${this.name}입니다!`);
    }
  };

  user1.greet(); // 안녕하세요, 홍길동입니다!
  user2.greet(); // 안녕하세요, 김철수입니다!
```
  문제점: 같은 코드를 계속 반복해야 함 😱

  ---
  2. 클래스로 객체 만들기 (모던 방식)
```js
  // User 클래스 정의 (설계도)
  class User {
    // 생성자: 객체를 만들 때 실행되는 함수
    constructor(name, age) {
      this.name = name;  // this = 지금 만들어지는 객체
      this.age = age;
    }

    // 메서드: 객체가 할 수 있는 행동
    greet() {
      console.log(`안녕하세요, ${this.name}입니다!`);
    }

    getAge() {
      return `저는 ${this.age}살입니다.`;
    }
  }

  // 클래스로 객체 만들기 (인스턴스 생성)
  const user1 = new User('홍길동', 25);
  const user2 = new User('김철수', 30);

  user1.greet(); // 안녕하세요, 홍길동입니다!
  user2.greet(); // 안녕하세요, 김철수입니다!

  console.log(user1.getAge()); // 저는 25살입니다.
  console.log(user2.getAge()); // 저는 30살입니다.
```
  장점: 한 번 만들어놓으면 계속 재사용! ✨

  ---
  3. 클래스 구조 자세히 보기
```js
  class Car {
    // 👈 생성자: new Car() 할 때 실행됨
    constructor(brand, color) {
      this.brand = brand;    // 속성(프로퍼티) 설정
      this.color = color;
      this.speed = 0;        // 기본값 설정
    }

    // 👈 메서드들: 객체가 할 수 있는 행동
    start() {
      console.log(`${this.brand} 자동차 시동을 걸었습니다!`);
    }

    accelerate(amount) {
      this.speed += amount;
      console.log(`속도가 ${this.speed}km/h로 증가했습니다.`);
    }

    brake() {
      this.speed = 0;
      console.log('브레이크를 밟았습니다. 정지!');
    }

    getInfo() {
      return `${this.color} ${this.brand}, 현재 속도: ${this.speed}km/h`;
    }
  }

  // 사용해보기
  const myCar = new Car('현대', '빨간색');

  console.log(myCar.brand);  // 현대
  console.log(myCar.color);  // 빨간색
  console.log(myCar.speed);  // 0

  myCar.start();             // 현대 자동차 시동을 걸었습니다!
  myCar.accelerate(50);      // 속도가 50km/h로 증가했습니다.
  myCar.accelerate(30);      // 속도가 80km/h로 증가했습니다.
  console.log(myCar.getInfo()); // 빨간색 현대, 현재 속도: 80km/h
  myCar.brake();             // 브레이크를 밟았습니다. 정지!
```
  ---
  4. this가 뭔가요?

  this는 **"지금 이 객체"** 를 가리키는 키워드예요.
```js
  class Person {
    constructor(name) {
      this.name = name;  // 👈 this = 지금 만들어지는 객체
    }

    introduce() {
      console.log(`제 이름은 ${this.name}입니다.`); // 👈 this = 이 메서드를 호출한
  객체
    }
  }

  const person1 = new Person('홍길동');
  const person2 = new Person('김철수');

  person1.introduce(); // 👈 여기서 this = person1
  person2.introduce(); // 👈 여기서 this = person2

  결과:
  제 이름은 홍길동입니다.  (person1.introduce에서 this.name = '홍길동')
  제 이름은 김철수입니다.  (person2.introduce에서 this.name = '김철수')
```
  ---
  5. 에러 클래스 만들어보기 (server.js 스타일)

  이제 아까 본 에러 클래스를 이해해봅시다!
```js
  // 기본 Error 클래스를 확장
  class AppError extends Error {
    constructor(message, statusCode) {
      super(message);                    // 👈 부모 클래스(Error)의 생성자 호출
      this.statusCode = statusCode;      // 👈 HTTP 상태 코드 추가
      this.isOperational = true;         // 👈 예상 가능한 에러인지 표시
    }
  }

  // 사용해보기
  const error1 = new AppError('사용자를 찾을 수 없습니다', 404);
  const error2 = new AppError('권한이 없습니다', 403);

  console.log(error1.message);        // 사용자를 찾을 수 없습니다
  console.log(error1.statusCode);     // 404
  console.log(error1.isOperational);  // true

  console.log(error2.message);        // 권한이 없습니다
  console.log(error2.statusCode);     // 403
```
  ---
  6. 실전 예시 - 간단한 API 응답 클래스
```js
  class APIResponse {
    constructor(success, data, message) {
      this.success = success;
      this.data = data;
      this.message = message;
      this.timestamp = new Date().toISOString();
    }

    // 성공 응답 만들기
    static success(data, message = 'Success') {
      return new APIResponse(true, data, message);
    }

    // 에러 응답 만들기
    static error(message, data = null) {
      return new APIResponse(false, data, message);
    }

    // JSON으로 변환
    toJSON() {
      return {
        success: this.success,
        data: this.data,
        message: this.message,
        timestamp: this.timestamp
      };
    }
  }

  // Express에서 사용
  app.get('/users/:id', (req, res) => {
    try {
      const userId = req.params.id;

      if (userId === '999') {
        const errorResponse = APIResponse.error('사용자를 찾을 수 없습니다');
        return res.status(404).json(errorResponse.toJSON());
      }

      const user = { id: userId, name: `사용자${userId}` };
      const successResponse = APIResponse.success(user, '사용자 조회 성공');

      res.json(successResponse.toJSON());

    } catch (error) {
      const errorResponse = APIResponse.error('서버 에러가 발생했습니다');
      res.status(500).json(errorResponse.toJSON());
    }
  });
```
  결과:
  # 성공
  curl "http://localhost:9000/users/123"
  ```js
   {
     "success": true,
     "data": {"id": "123", "name": "사용자123"},
     "message": "사용자 조회 성공",
     "timestamp": "2024-01-01T12:00:00.000Z"
   }

```
  # 에러
  ```bash
  curl "http://localhost:9000/users/999"
```

 ```js
   {
     "success": false,
     "data": null,
     "message": "사용자를 찾을 수 없습니다",
     "timestamp": "2024-01-01T12:00:00.000Z"
   }
```

  ---
  7. static 메서드가 뭔가요?

  static 메서드는 클래스 자체에서 호출하는 메서드예요.
```js
  class MathHelper {
    // 일반 메서드 (인스턴스 필요)
    constructor(number) {
      this.number = number;
    }

    square() {
      return this.number * this.number;
    }

    // static 메서드 (인스턴스 불필요)
    static add(a, b) {
      return a + b;
    }

    static multiply(a, b) {
      return a * b;
    }
  }

  // 일반 메서드 사용
  const math = new MathHelper(5);
  console.log(math.square()); // 25

  // static 메서드 사용 (new 없이 바로 호출)
  console.log(MathHelper.add(3, 4));      // 7
  console.log(MathHelper.multiply(2, 6)); // 12
```
  ---
  8. 상속 (extends)
```js
  // 부모 클래스
  class Animal {
    constructor(name) {
      this.name = name;
    }

    speak() {
      console.log(`${this.name}가 소리를 냅니다.`);
    }
  }

  // 자식 클래스
  class Dog extends Animal {
    constructor(name, breed) {
      super(name);        // 👈 부모 생성자 호출
      this.breed = breed;
    }

    speak() {            // 👈 부모 메서드 오버라이드
      console.log(`${this.name}가 멍멍 짖습니다!`);
    }

    fetch() {            // 👈 새로운 메서드 추가
      console.log(`${this.name}가 공을 가져옵니다.`);
    }
  }

  const dog = new Dog('바둑이', '진돗개');
  dog.speak();  // 바둑이가 멍멍 짖습니다!
  dog.fetch();  // 바둑이가 공을 가져옵니다.
```

 super는 자식 클래스에서 부모 클래스의 생성자나 메서드를 호출할 때 사용해요.

  ---
  1. 기본 상속 구조 이해하기

```js
  // 부모 클래스
  class Animal {
    constructor(name, age) {
      this.name = name;
      this.age = age;
      console.log(`동물 ${name}이 생성되었습니다.`);
    }

    speak() {
      console.log(`${this.name}가 소리를 냅니다.`);
    }

    info() {
      console.log(`이름: ${this.name}, 나이: ${this.age}`);
    }
  }

  // 자식 클래스
  class Dog extends Animal {  // Animal을 상속받음
    constructor(name, age, breed) {
      // 👈 부모의 생성자 호출 (필수!)
      super(name, age);  // Animal의 constructor(name, age) 호출

      this.breed = breed; // 자식만의 속성 추가
      console.log(`강아지 ${name}(${breed})이 생성되었습니다.`);
    }
  }

  const dog = new Dog('바둑이', 3, '진돗개');
  // 출력:
  // 동물 바둑이가 생성되었습니다.  (부모 생성자)
  // 강아지 바둑이(진돗개)이 생성되었습니다.  (자식 생성자)
```

  ---

  2. super()가 왜 필요한가요?

  ❌ super() 없으면 에러!

```js
  class Dog extends Animal {
    constructor(name, age, breed) {
      // super(name, age);  // 이 줄이 없으면...
      this.breed = breed; // ❌ ReferenceError: Must call super constructor!
    }
  }
```

  ✅ super()의 역할

```js
  class Dog extends Animal {
    constructor(name, age, breed) {
      super(name, age);  // 1. 부모 생성자 호출
                         // 2. this.name = name, this.age = age 설정
                         // 3. 이제 this 사용 가능!

      this.breed = breed; // 4. 자식만의 속성 추가
    }
  }
```

  규칙: 자식 클래스에서 constructor를 정의하면 반드시 super()를 먼저 호출해야 해요!

  ---
  3. super로 부모 메서드 호출하기

```js
  class Animal {
    constructor(name) {
      this.name = name;
    }

    speak() {
      return `${this.name}가 소리를 냅니다.`;
    }

    sleep() {
      return `${this.name}가 잠을 잡니다.`;
    }
  }

  class Dog extends Animal {
    constructor(name, breed) {
      super(name); // 부모 생성자 호출
      this.breed = breed;
    }

    speak() {
      // 부모의 speak() 메서드 호출 + 추가 내용
      const parentResult = super.speak(); // "바둑이가 소리를 냅니다."
      return parentResult + " 멍멍!";      // "바둑이가 소리를 냅니다. 멍멍!"
    }

    sleep() {
      // 부모 메서드 그대로 사용
      return super.sleep(); // Animal의 sleep() 메서드 호출
    }
  }

  const dog = new Dog('바둑이', '진돗개');
  console.log(dog.speak()); // 바둑이가 소리를 냅니다. 멍멍!
  console.log(dog.sleep()); // 바둑이가 잠을 잡니다.
```

  ---
  4. 실제 사용 예시 - 사용자 클래스

```js
  // 기본 사용자 클래스
  class User {
    constructor(name, email) {
      this.name = name;
      this.email = email;
      this.createdAt = new Date();
      console.log(`사용자 ${name}이 생성되었습니다.`);
    }

    login() {
      console.log(`${this.name}님이 로그인했습니다.`);
    }

    getInfo() {
      return {
        name: this.name,
        email: this.email,
        createdAt: this.createdAt
      };
    }
  }

  // 관리자 클래스
  class Admin extends User {
    constructor(name, email, permissions) {
      super(name, email); // 부모 생성자 호출
      this.permissions = permissions;
      this.role = 'admin';
      console.log(`관리자 ${name}에게 권한 ${permissions.join(', ')}이
  부여되었습니다.`);
    }

    login() {
      super.login(); // 부모의 login() 호출
      console.log(`관리자 권한으로 로그인되었습니다.`);
    }

    getInfo() {
      const parentInfo = super.getInfo(); // 부모의 getInfo() 호출
      return {
        ...parentInfo,  // 부모 정보 확산
        role: this.role,
        permissions: this.permissions
      };
    }

    deleteUser(userId) {
      console.log(`관리자 ${this.name}이 사용자 ${userId}를 삭제했습니다.`);
    }
  }

  const admin = new Admin('김관리', 'admin@test.com', ['read', 'write', 'delete']);
  // 출력:
  // 사용자 김관리이 생성되었습니다.
  // 관리자 김관리에게 권한 read, write, delete이 부여되었습니다.

  admin.login();
  // 출력:
  // 김관리님이 로그인했습니다.
  // 관리자 권한으로 로그인되었습니다.

  console.log(admin.getInfo());
  // 출력:
  // {
  //   name: '김관리',
  //   email: 'admin@test.com',
  //   createdAt: 2024-01-01T...,
  //   role: 'admin',
  //   permissions: ['read', 'write', 'delete']
  // }
```

  ---
  5. server.js의 에러 클래스에서 super 사용

  아까 본 에러 클래스를 다시 보면:
```js
  class AppError extends Error {  // Error 클래스 상속
    constructor(message, statusCode) {
      super(message);              // 👈 Error의 생성자 호출
      this.statusCode = statusCode;
      this.isOperational = true;
    }
  }
```

  이게 하는 일:
```js
  // super(message)는 이렇게 동작
  // Error의 생성자에서:
  // this.message = message;
  // this.name = 'Error';
  // this.stack = ... (에러 스택 트레이스)

  // 그 다음에 AppError에서:
  // this.statusCode = statusCode;
  // this.isOperational = true;
```
  사용해보기:
```js
  class AppError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.statusCode = statusCode;
      this.isOperational = true;
    }
  }

  const error = new AppError('사용자를 찾을 수 없습니다', 404);

  console.log(error.message);        // 사용자를 찾을 수 없습니다 (부모에서)
  console.log(error.statusCode);     // 404 (자식에서)
  console.log(error.isOperational);  // true (자식에서)
  console.log(error.stack);          // 에러 스택 (부모에서)

  // Error 메서드도 사용 가능
  console.log(error.toString());     // Error: 사용자를 찾을 수 없습니다
```
  ---
  6. super 사용시 주의사항

  A) constructor에서 super()는 맨 먼저!

```js
  class Child extends Parent {
    constructor(name, age) {
      // ❌ super() 전에 this 사용 불가
      // this.age = age;  // ReferenceError!

      super(name);      // ✅ 먼저 super() 호출
      this.age = age;   // ✅ 이제 this 사용 가능
    }
  }
```

  B) 메서드에서는 언제든 super 사용 가능

```js
  class Child extends Parent {
    method() {
      console.log('자식 메서드 시작');
      super.method();  // 부모 메서드 호출
      console.log('자식 메서드 끝');
    }
  }
```
  ---
  7. 실습해보기

  Vehicle → Car → SportsCar 3단계 상속:

```js
  // 1단계: 기본 차량
  class Vehicle {
    constructor(brand, year) {
      this.brand = brand;
      this.year = year;
      this.speed = 0;
      console.log(`${year}년 ${brand} 차량이 생성되었습니다.`);
    }

    start() {
      console.log(`${this.brand} 시동을 걸었습니다.`);
    }

    accelerate(amount) {
      this.speed += amount;
      console.log(`속도가 ${this.speed}km/h가 되었습니다.`);
    }
  }

  // 2단계: 일반 자동차
  class Car extends Vehicle {
    constructor(brand, year, doors) {
      super(brand, year); // Vehicle 생성자 호출
      this.doors = doors;
      console.log(`${doors}문 자동차가 준비되었습니다.`);
    }

    start() {
      super.start(); // Vehicle의 start() 호출
      console.log('자동차가 준비되었습니다.');
    }
  }

  // 3단계: 스포츠카
  class SportsCar extends Car {
    constructor(brand, year, doors, maxSpeed) {
      super(brand, year, doors); // Car 생성자 호출
      this.maxSpeed = maxSpeed;
      console.log(`최고속도 ${maxSpeed}km/h 스포츠카 완성!`);
    }

    start() {
      super.start(); // Car의 start() 호출
      console.log('스포츠카 모드 활성화!');
    }

    accelerate(amount) {
      if (this.speed + amount > this.maxSpeed) {
        console.log(`최고속도 ${this.maxSpeed}km/h를 초과할 수 없습니다.`);
        this.speed = this.maxSpeed;
      } else {
        super.accelerate(amount); // Vehicle의 accelerate() 호출
      }
    }
  }

  const sportsCar = new SportsCar('페라리', 2023, 2, 300);
  // 출력:
  // 2023년 페라리 차량이 생성되었습니다.
  // 2문 자동차가 준비되었습니다.
  // 최고속도 300km/h 스포츠카 완성!

  sportsCar.start();
  // 출력:
  // 페라리 시동을 걸었습니다.
  // 자동차가 준비되었습니다.
  // 스포츠카 모드 활성화!

  sportsCar.accelerate(350); // 최고속도 초과 시도
  // 출력: 최고속도 300km/h를 초과할 수 없습니다.
```

  ---
  정리하면:
  - super(): 부모 생성자 호출
  - super.method(): 부모 메서드 호출
  - 자식에서 부모 기능을 확장하거나 재사용할 때 사용

  ---
  9. 실습해보기

  간단한 Logger 클래스 만들어보세요:

```js
  class Logger {
    constructor(name) {
      this.name = name;
      this.logs = [];
    }

    info(message) {
      const log = {
        level: 'INFO',
        message: message,
        timestamp: new Date().toISOString(),
        logger: this.name
      };
      this.logs.push(log);
      console.log(`[INFO] ${this.name}: ${message}`);
    }

    error(message) {
      const log = {
        level: 'ERROR',
        message: message,
        timestamp: new Date().toISOString(),
        logger: this.name
      };
      this.logs.push(log);
      console.error(`[ERROR] ${this.name}: ${message}`);
    }

    getLogs() {
      return this.logs;
    }

    clear() {
      this.logs = [];
      console.log(`${this.name} 로그가 초기화되었습니다.`);
    }
  }

  // 사용해보기
  const apiLogger = new Logger('API');
  const dbLogger = new Logger('Database');

  apiLogger.info('사용자 요청 처리 시작');
  apiLogger.error('API 호출 실패');

  dbLogger.info('데이터베이스 연결');
  dbLogger.error('쿼리 실행 실패');

  console.log('API 로그:', apiLogger.getLogs());
  console.log('DB 로그:', dbLogger.getLogs());
```